{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# NumPy: the absolute basics for beginners\n",
    "\n",
    "このテキストは、Numpy: the absolute basic for beginnersのHPを翻訳及び記載/補足し、jupyter Notebookで学習できるように編集したものです。  \n",
    "  \n",
    "【免責事項】\n",
    "  \n",
    "1. 本ソフトウェア（及びその複写物）を使用することで生じるリスクは、利用者が負うものとします。NPO法人AI開発推進協会（以下「本法人」といいます）では、明示的な瑕疵担保責任または保証を一切行いません。\n",
    "2. 本法人は、利用者に対し、本ソフトウェア（及びその複写物）に関して、その動作、商品性、特定用途への適合性その他一切の保証を行いません。\n",
    "3. 本法人は、利用者及び第三者が本ソフトウェアに関連して直接又は間接的に被ったいかなる損害についても、一切の責任を負いません。利用者は、本ソフトウェアの使用に関して第三者からされた請求に関する損害、損失あるいは責任より本法人を免責するものとします。  \n",
    "  \n",
    "©️ 2021 NPO法人AI開発推進協会  \n",
    "This software is released under the MIT License. http://opensource.org/licenses/mit-license.php  \n",
    "  \n",
    "***  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "NumPyの（まったくの）初心者ガイドへようこそ! ご意見やご提案がありましたら、遠慮なくお寄せください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">NumPyへようこそ!</span>\n",
    "  \n",
    "NumPy (Numerical Python) は、科学や工学のほぼすべての分野で使用されているオープンソースの Python ライブラリです。これは Python で数値データを扱うための普遍的な標準であり、科学的な Python と PyData のエコシステムの中核をなしています。NumPyのユーザーは、初心者のコーダーから、最先端の科学や産業の研究開発を行っている経験豊富な研究者まで、誰もが参加しています。NumPy APIはPandas、SciPy、Matplotlib、scikit-learn、scikit-image、その他ほとんどのデータサイエンスや科学的Pythonパッケージで幅広く使用されています。\n",
    "  \n",
    "NumPyライブラリには多次元配列と行列データ構造が含まれています（これについては後のセクションで詳しく説明します）。均質な n 次元配列オブジェクトである ndarray と、その上で効率的に操作するためのメソッドを提供します。NumPy は配列に対する様々な数学的操作を行うために使用できます。 <span style=\"color: red; \">配列や行列を使った効率的な計算を保証する強力なデータ構造をPythonに追加し、これらの配列や行列を操作する高レベルの数学関数の膨大なライブラリを提供します</span>。\n",
    "  \n",
    "NumPyについての詳細は[こちら](https://numpy.org/devdocs/user/whatisnumpy.html#whatisnumpy)!\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">NumPyのインストール</span>\n",
    "NumPyをインストールするには、科学的向けPythonディストリビューションを使うことを強くお勧めします。お使いのオペレーティングシステムにNumPyをインストールするための完全な手順をお探しの場合は、[ここですべての詳細を見つける](https://www.scipy.org/install.html)ことができます。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "すでにPythonをお持ちの方は、下記のコマンドを使ってNumPyをインストールしておきましょう。\n",
    "***   \n",
    "`conda install numpy*`   \n",
    "***  \n",
    "        or              \n",
    "***  \n",
    "`pip install numpy*`      \n",
    "\n",
    "<span style=\"color: gray; \">［補足］本学習環境(DeepAelurus）では既にインストールされているので不要です。</span>\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "もしあなたがまだ Python を持っていないのであれば、Anaconda の使用を検討してみてはいかがでしょうか。これが一番簡単に始められる方法です。このディストリビューションの良いところは、NumPy や pandas, Scikit-Learn などのようなデータ解析に使用する主要なパッケージを別途インストールする必要がないことです。\n",
    "  \n",
    "インストールの詳細は[SciPy](https://www.scipy.org/)の[Installationセクション](https://www.scipy.org/install.html)\n",
    "にあります。\n",
    "  \n",
    "<span style=\"color: gray; \">［補足］本学習環境(DeepAelurus）では不要です。</span>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">NumPyのインポート方法</span>  \n",
    "パッケージやライブラリをコードの中で使いたいときはいつでも、まずそれにアクセスできるようにする必要があります。\n",
    "\n",
    "NumPy と NumPy で利用できるすべての関数を使い始めるには、NumPy をインポートする必要があります。これは、このインポート文で簡単にできます。  \n",
    "  \n",
    "<span style=\"color: gray; \"> [補足]　操作に対する補足  \n",
    "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 学習する際（途中からの再開を含む）は、以下のimport文を実施してください。   \n",
    "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- テキスト部分は「↓」ボタンでスクロール、各コマンドラインは「shift]+「retutn」キーで順番に実行してください。   \n",
    "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- テキスト画面を編集で開いた場合は「shift]+「retutn」で閉じてください。  \n",
    "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（デフォルトではロックして編集はできないようになっています）  \n",
    "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 誤ってテキストを編集した場合は、「Ctrl」+「z」で取り消すことができます。  \n",
    "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 追加で動作確認したい場合は任意の場所でセル（メニューバーのInsert（挿入））を追加して試してください。</span>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "import numpy as np"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "（<span style=\"color: red; \">numpy を np と短縮することで時間を節約し、そしてまたコードを標準化しておくことで、あなたのコードを使って作業している誰もが簡単に理解して実行できるようにしています</span>。）"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">コード例を読みかた</span>\n",
    "\n",
    "多くのコードを含むチュートリアルを読むことにまだ慣れていない場合、このようなコードブロックをどのように解釈すればいいのかわからないかもしれません。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.arange(6)\n",
    "a2 = a[np.newaxis, :]\n",
    "a2.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "このスタイルに慣れていない人でも、とてもわかりやすいと思います。  \n",
    "もし >>> が見えていたら、あなたは入力、つまりあなたが入力するコードを見ていることになります。前に >>> がないものはすべて出力、つまりコードを実行した結果です。これはpythonをコマンドラインで実行しているときに表示されるスタイルですが、IPythonを使っている場合は違うスタイルが表示されるかもしれません。\n",
    "\n",
    "<span style=\"color: gray; \">［補足］本テキストはIPythonです。したがって入力は In [&nbsp;]またはIn[n]、出力は Out[n]が左端に表示されます（nは実行順を示す数字）。　</span>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">PythonのリストとNumPyの配列の違いなんですか？</span>\n",
    "\n",
    "NumPyは、配列を作成したり、その中の数値データを操作したりするための高速かつ効率的な方法を提供してくれます。<span style=\"color: red; \">Pythonのリストは1つのリスト内に異なるデータ型を含むことができますが、NumPyの配列内のすべての要素は同種でなければなりません</span>。もし配列が同種でなければ、配列上で実行されることを意図した数学的な操作は非常に非効率的です。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "### なぜNumPyを使うのか？\n",
    "\n",
    "<span style=\"color: red; \">NumPyの配列はPythonのリストよりも高速でコンパクトです。配列はメモリ消費量が少なくて便利です</span>。NumPyはデータを格納するのに使用するメモリがかなり少なく、データ型を指定する仕組みを提供しています。これにより、コードをさらに最適化することができます。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">配列とは何ですか？</span>\n",
    "<span style=\"color: red; \">配列はNumPyライブラリの中心的なデータ構造です</span>。配列は値のグリッドであり、生データに関する情報、要素の探し方、要素の解釈方法などが含まれています。要素のグリッドを持ち、様々な方法でインデックスを作成することができます。要素はすべて同じ型で、配列のdtypeと表されれます。\n",
    "\n",
    "<span style=\"color: red; \">配列は，非負の整数のタプル，ブーリアン，別の配列，または整数によってインデックスを作成することができます。配列のランク（rank）は，次元数です。配列の形状（shape）は，各次元に沿った配列のサイズを与える整数のタプルです</span>。\n",
    "\n",
    "NumPyの配列を初期化する方法の1つとしてPythonのリストを使います。2次元以上のデータは入れ子になったリストを使います。\n",
    "\n",
    "例えば，以下のようになります．\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([1, 2, 3, 4, 5, 6])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列の要素には角括弧を使ってアクセスします。要素にアクセスするときは、<span style=\"color: red; \">NumPyのインデックスは0から始まる</span>ことを覚えておいてください。 つまり、配列の最初の要素にアクセスしたい場合は、要素 \"0 \"にアクセスすることになります。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "print(a[0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">配列の詳細情報</span>\n",
    "1次元配列、2次元配列、ndarray、ベクトル、行列について説明します。  \n",
    "***  \n",
    "たまに「NDARRAY」と呼ばれる配列を耳にすることがありますが、これは「N次元配列」の略語です。N次元配列とは、単純に任意の次元数の配列のことです。**1-D**、**１次元配列**, **2-D**, **２次元配列**などと呼ばれることもあります。NumPyのndarrayクラスは、行列とベクトルの両方を表現するのに使われます。<span style=\"color: red; \">ベクトルは1次元の配列（行ベクトルと列ベクトルの違いはありません）であり，行列は2次元の配列を指します。3次元またはそれ以上の次元の配列では，テンソル</span>という用語もよく使われます。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">配列の属性とは何ですか？</span>\n",
    "\n",
    "配列とは、通常、同じ種類＆サイズの項目の固定サイズの容器です。配列の次元と項目の数は、その形状によって定義されます。配列の形状は、各次元のサイズを指定する非負の整数のタプルです。\n",
    "\n",
    "NumPyでは、<span style=\"color: red; \">次元は軸（axis）と呼ばれます</span>。つまり、次のような2次元配列があれば、以下のようになります。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "[[0., 0., 0.],\n",
    " [1., 1., 1.]]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列には2つの軸があります。1つ目の軸の長さは2、2つ目の軸の長さは3です。\n",
    "\n",
    "他のPythonコンテナオブジェクトと同様に、配列の内容はインデックスを作成したりスライスしたりすることでアクセスしたり変更したりすることができます。典型的なコンテナオブジェクトとは異なり、異なる配列は同じデータを共有することができるので、ある配列で行われた変更は別の配列でも見ることができます。\n",
    "\n",
    "配列の属性は、配列自体に内在する情報を反映しています。新しい配列を作成せずに配列のプロパティを取得したり設定したりする必要がある場合は、その属性を使用して配列にアクセスすることができます。\n",
    "\n",
    "配列の属性についての詳細は[こちら](https://numpy.org/devdocs/reference/arrays.ndarray.html#arrays-ndarray)を、配列オブジェクトについては[こちら](https://numpy.org/devdocs/reference/arrays.html#arrays)をご覧ください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">基本的な配列の作り方</span>\n",
    "ここでは，np.array()，np.zeros()，np.ones()，np.empty()，np.arange()，np.linspace()，dtypeを扱います．  \n",
    "***  \n",
    "<span style=\"color: red; \">NumPy配列を作成するには、関数np.array()を使用します</span>。\n",
    "\n",
    "単純な配列を作成するために必要なのは、リストを渡すだけです。必要に応じて、リストに含まれるデータの型を指定することもできます。データ型についての詳細は[こちら](https://numpy.org/devdocs/reference/arrays.dtypes.html#arrays-dtypes)をご覧ください。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "a = np.array([1, 2, 3])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "このようにして配列を可視化することができます。\n",
    "\n",
    "![picture](https://numpy.org/devdocs/_images/np_array.png)\n",
    "これらの可視化は，概念を単純化し，NumPyの概念と力学の基本的な理解を得るためのものであることに注意してください．配列や配列操作はここで紹介したものよりもはるかに複雑です。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "要素の並びから配列を作成する以外にも、<span style=\"color: red; \">0で埋め尽くされた配列を簡単に作成する</span>ことができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.zeros(2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "または、<span style=\"color: red; \">1を埋めた配列を作成する</span>こともできます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.ones(2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "空の配列でも良いのです! 関数 empty は、最初の内容がランダムでメモリの状態に依存する配列を作成します。<span style=\"color: red; \">ゼロよりも空の配列を使う理由は、速度を上げる</span>ためです。\n",
    "ただ、後ですべての要素を必ず埋めてください。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "# Create an empty array with 2 elements\n",
    "np.empty(2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "要素の範囲で配列を作成することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.arange(4)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "さらには、等間隔の範囲を含む配列も作成できます。これを行うには、最初の番号、最後の番号、間隔を指定します。  \n",
    "<span style=\"color: red; \">［補足］最後の番号(n)は含まず、n-1までになります</span>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.arange(2, 9, 2)     #［補足］2から8(9-1)まで間隔２で作成"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "np.linspace() を使用して、指定した間隔で直線的に間隔を置いた値を持つ配列を作成することもできます。  \n",
    "<span style=\"color: red; \">［補足］linspace()では、最後の番号(n)を含みます</span>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.linspace(0, 10, num=5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "### データタイプの指定\n",
    "\n",
    "<span style=\"color: red; \">既定のデータ型は浮動小数点 (np.float64) です</span>が、dtype キーワードを使用して、どのデータ型を使用するかを明示的に指定できます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "x = np.ones(2, dtype=np.int64)\n",
    "x"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列の作成についての詳細はこちらを[参照](https://numpy.org/devdocs/user/quickstart.html#quickstart-array-creation)してください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">要素の追加、削除、ソート</span>  \n",
    "  \n",
    "このセクションでは、np.sort()、np.concatenate()について説明します。  \n",
    "***\n",
    "要素のソートはnp.sort()で簡単にできます。関数を呼び出すときに軸、種類、順序を指定できます。\n",
    "\n",
    "下記の配列で始めると、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "arr = np.array([2, 1, 5, 3, 7, 4, 6, 8])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "こうして昇順に素早く並び替えることができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.sort(arr)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列のソートされたコピーを返す sort に加えて、次のようなものが使えます。\n",
    "\n",
    "- [argsort](https://numpy.org/devdocs/reference/generated/numpy.argsort.html#numpy.argsort) 、指定した軸に沿った間接的なソートです。\n",
    "  \n",
    "- [lexsort](https://numpy.org/devdocs/reference/generated/numpy.lexsort.html#numpy.lexsort)、複数のキーに対して間接的に安定したソートを行う 。\n",
    "  \n",
    "- [searchsorted](https://numpy.org/devdocs/reference/generated/numpy.searchsorted.html#numpy.searchsorted) 、ソートされた配列の要素を見つけます。\n",
    "  \n",
    "- [partition](https://numpy.org/devdocs/reference/generated/numpy.partition.html#numpy.partition)、これは部分的なソートです。\n",
    "  \n",
    "配列のソートについての詳細は、 [sort](https://numpy.org/devdocs/reference/generated/numpy.sort.html#numpy.sort) を参照してください。\n",
    "  \n",
    "下記のこれらの配列から始めると、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([1, 2, 3, 4])\n",
    "b = np.array([5, 6, 7, 8])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "<span style=\"color: red; \">np.concatenate()で連結することができます</span>。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.concatenate((a, b))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "あるいは、これらの配列から始めると、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "x = np.array([[1, 2], [3, 4]])\n",
    "y = np.array([[5, 6]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "下記で連携ができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.concatenate((x, y), axis=0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列から要素を削除するには、インデックスを使って保持したい要素を選択するのが簡単です。\n",
    "\n",
    "連結についての詳細は [concatenate](https://numpy.org/devdocs/reference/generated/numpy.concatenate.html#numpy.concatenate) を参照してください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">配列の形状やサイズを知るにはどうすればいいのでしょうか？</span>    \n",
    "このセクションでは、ndarray.ndim、ndarray.size、ndarray.shapeを扱います。\n",
    "***\n",
    "<span style=\"color: red; \">ndarray.ndim は配列の軸数、つまり次元を教えてくれます</span>。\n",
    "\n",
    "<span style=\"color: red; \">ndarray.size は配列の要素の総数を示します。これは配列の形状の要素の積です</span>。\n",
    "\n",
    "<span style=\"color: red; \">ndarray.shape は、配列の各次元に沿って格納されている要素の数を示す整数のタプルを表示します</span>。例えば、2行3列の2次元配列を作成した場合、配列の形状は(2, 3)となります。\n",
    "\n",
    "例えば、以下のような配列を作成したとします。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "array_example = np.array([[[0, 1, 2, 3],\n",
    "                          [4, 5, 6, 7]],\n",
    "                          \n",
    "                          [[0, 1, 2, 3],\n",
    "                           [4, 5, 6, 7]],\n",
    "                          \n",
    "                          [[0 ,1 ,2, 3],\n",
    "                           [4, 5, 6, 7]]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列の次元数を調べるには、次のように実行します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "array_example.ndim"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列の総要素数を求めるには，次のように実行します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "array_example.size"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "そして，配列の形状を求めるには，次のように実行します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "array_example.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">配列のリシェイプはできますか？</span>  \n",
    "  \n",
    "この節では arr.reshape() を扱います。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "**できます!**\n",
    "\n",
    "<span style=\"color: red; \">arr.reshape() を使用すると、データを変更することなく配列に新しい形を与えることができます</span>。ただ、reshape メソッドを使用する際には、生成したい配列の要素数が元の配列と同じである必要があることを覚えておいてください。12 個の要素を持つ配列から始めた場合、新しい配列も合計 12 個の要素を持つようにしなければなりません。\n",
    "\n",
    "以下の配列で始めた場合、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.arange(6)\n",
    "print(a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "reshape() を使用して、配列の形状を変更することができます。たとえば、この配列を 3 行 2 列の配列にリシェイプすることができます。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "b = a.reshape(3, 2)\n",
    "print(b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "np.reshapeでは、いくつかのオプションのパラメータを指定することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.reshape(a, newshape=(1, 6), order='C')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "a はリシェイプされる配列です。  \n",
    "  \n",
    "newshape：新しい形状を指定します。整数か整数のタプルを指定することができます。整数を指定した場合、結果はその長さの配列になります。形状は元の形状と互換性のあるものでなければなりません。\n",
    "  \n",
    "order：C は C ライクなインデックス順で要素を読み書きすることを意味し、F は Fortran ライクなインデックス順で要素を読み書きすることを意味し、A は a がメモリ内で Fortran が連続している場合は Fortran ライクなインデックス順で要素を読み書きすることを意味し、そうでない場合は C ライクなインデックス順で要素を読み書きすることを意味します。(これはオプションのパラメータであり、指定する必要はありません)。\n",
    "  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "CとFortranの順序についてもっと知りたい場合は、[ここで](https://numpy.org/devdocs/reference/internals.html#numpy-internals)NumPy配列の内部組織についての詳細を読むことができます。基本的に、CとFortranの順序は、配列がメモリに格納されている順序にインデックスがどのように対応するかに関係しています。Fortranでは、メモリに格納されている2次元配列の要素を移動するとき、最初のインデックスが最も急速に変化するインデックスです。最初のインデックスが変化しながら次の行に移動すると、行列は1列ずつ格納されます。これがFortranがカラムメジャー言語として考えられている理由です。一方、C言語では、最後のインデックスが最も早く変化します。行列は行単位で格納されるので、行メジャー言語になります。CとFortranのどちらをどうするかは、インデックスの規則を守ることと、データの並び替えをしないことのどちらが重要かにかかっています。  \n",
    "  \n",
    "形状操作については[こちら](https://numpy.org/devdocs/user/quickstart.html#quickstart-shape-manipulation)をご覧ください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">1次元配列を2次元配列に変換する方法（配列に新しい軸を追加する方法）</span>\n",
    "ここでは、np.newaxis、np.expand_dimsを扱います。\n",
    "***\n",
    "<span style=\"color: red; \">np.newaxis と np.expand_dims を使用して、既存の配列の寸法を増やすことができます</span>。\n",
    "\n",
    "np.newaxisを使用すると、1回使用すると配列の次元が1次元増加します。これは、1次元配列が2次元配列になり、2次元配列が3次元配列になることを意味します。\n",
    "\n",
    "例えば、以下の配列から始めた場合、\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([1, 2, 3, 4, 5, 6])\n",
    "a.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "np.newaxisを使用して新しい軸を追加することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a2 = a[np.newaxis, :]\n",
    "a2.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "np.newaxis を使用して，明示的に 1 次元配列を行ベクトルまたは列ベクトルに変換することができます．例えば，1 次元に沿って軸を挿入することで，1 次元配列を行ベクトルに変換することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "row_vector = a[np.newaxis, :]\n",
    "row_vector.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "または、列ベクトルの場合は、2次元に沿って軸を挿入することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "col_vector = a[:, np.newaxis]\n",
    "col_vector.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "また、np.expand_dimsで指定した位置に新しい軸を挿入して配列を拡張することもできます。  \n",
    "  \n",
    "例えば、以下ような配列から始めると、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([1, 2, 3, 4, 5, 6])\n",
    "a.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "np.expand_dimsを使ってインデックス位置1に軸を追加することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "b = np.expand_dims(a, axis=1)\n",
    "b.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "インデックス位置0に軸を追加することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "c = np.expand_dims(a, axis=0)\n",
    "c.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "newaxisについての詳細は[こちら](https://numpy.org/devdocs/reference/arrays.indexing.html#arrays-indexing)を、expand_dimsについては[expand_dims](https://numpy.org/devdocs/reference/generated/numpy.expand_dims.html#numpy.expand_dims)を参照してください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">インデックスとスライス</span>  \n",
    "  \n",
    "Pythonのリストをスライスするのと同じように、<span style=\"color: red; \">NumPyの配列をインデックス化してスライスすることができます</span>。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data = np.array([1, 2, 3])\n",
    "data[1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data[0:2]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data[1:]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data[-2:]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "このように可視化することができます。  \n",
    "  \n",
    "![picture](https://numpy.org/devdocs/_images/np_indexing.png)  \n",
    "  \n",
    "配列の一部や特定の配列要素を取り出して、さらなる分析や追加の操作に使用したい場合もあるでしょう。そのためには、配列のサブセット、スライス、インデックスを作成する必要があります。\n",
    "　　\n",
    "配列から特定の条件を満たす値を選択したい場合は、NumPyを使えば簡単です。\n",
    "\n",
    "例えば、次のような配列から始めると、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([[1 , 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列内の5以下の値をすべて簡単に表示することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "print(a[a < 5])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "また、例えば5以上の数値を選択して、その条件を使って配列のインデックスを作成することもできます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "five_up = (a >= 5)\n",
    "print(a[five_up])\n",
    "\n",
    "#[補足] five_upはbooleanのインデックスになります\n",
    "#   [[False False False False]\n",
    "#   [ True  True  True  True]\n",
    "#   [ True  True  True  True]]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "2で割り切れる要素を選択することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "divisible_by_2 = a[a%2==0]\n",
    "print(divisible_by_2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "または、&演算子と｜演算子を使って2つの条件を満たす要素を選択することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "c = a[(a > 2) & (a < 11)]\n",
    "print(c)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "また、論理演算子 & や | を使用して、配列内の値が特定の条件を満たすかどうかを指定するブール値を返すこともできます。これは、名前やその他のカテゴリカルな値を含む配列で便利です。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "five_up = (a > 5) | (a == 5)\n",
    "print(five_up)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "np.nonzero() を使用して、配列の要素やインデックスを選択することもできます。  \n",
    "  \n",
    "下記の配列から始めて、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "np.nonzero()を使用して、例えば5未満の要素のインデックスを表示することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false,
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "b = np.nonzero(a < 5)\n",
    "print(b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "この例では、配列のタプルが返されました。\n",
    "各次元に対して 1 つの配列が返されました。最初の配列は、これの値が見つかった行のインデックスを表し、2 番目の配列は、値が見つかった列のインデックスを表します。\n",
    "  \n",
    "<span style=\"color: red; \">要素が存在する座標のリストを生成したい場合は，配列をzip圧縮して，座標のリストを繰り返し処理し，それを表示することができます</span>。例えば、以下のようになります。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "list_of_coordinates= list(zip(b[0], b[1]))\n",
    "\n",
    "for coord in list_of_coordinates:\n",
    "    print(coord)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "np.nonzero()を使用して、配列の要素が5未満のものを表示することもできます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "print(a[b])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "探している要素が配列内に存在しない場合、返されるインデックスの配列は空となります。例えば、以下のようになります。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "not_there = np.nonzero(a == 42)\n",
    "print(not_there)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "インデックス作成とスライスについては、[ここ](https://numpy.org/devdocs/user/quickstart.html#quickstart-indexing-slicing-and-iterating)と[ここ](https://numpy.org/devdocs/user/basics.indexing.html#basics-indexing)を参照してください。  \n",
    "  \n",
    "nonzero 関数の使用についての詳細は[nonzero](https://numpy.org/devdocs/reference/generated/numpy.nonzero.html#numpy.nonzero)を参照してください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "既存のデータから配列を作成する方法\n",
    "\n",
    "このセクションでは、スライスとインデックス作成、np.vstack()、np.hstack()、np.hsplit()、.view()、copy()を扱います。\n",
    "***\n",
    "<span style=\"color: red; \">既存の配列の一部から新しい配列を作成することが簡単にできます</span>。  \n",
    "  \n",
    "このような配列があるとしましょう。  \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([1,  2,  3,  4,  5,  6,  7,  8,  9, 10])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列をスライスしたい場所を指定することで、いつでも配列の一部から新しい配列を作成することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "arr1 = a[3:8]\n",
    "arr1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "ここでは、インデックス位置3からインデックス位置8までの配列の部分を取得しています。  \n",
    "  \n",
    "また、<span style=\"color: red; \">既存の2つの配列を縦にも横にも重ねることができます</span>。2 つの配列 a1 と a2 があるとしましょう。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a1 = np.array([[1, 1],\n",
    "               [2, 2]])\n",
    "a2 = np.array([[3, 3],\n",
    "               [4, 4]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "vstackで縦に積み上げることができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.vstack((a1, a2))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "または hstack で水平にスタックします。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.hstack((a1, a2))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "hsplit を使用して、配列をいくつかの小さな配列に分割することができます。返される配列の数や分割後の列を指定することができます。\n",
    "\n",
    "次のような配列があるとしましょう。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "x = np.arange(1, 25).reshape(2, 12)\n",
    "x"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "この配列を3つの均等な形の配列に分割したい場合は、以下のように実行します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.hsplit(x, 3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "3列目と4列目の後に配列を分割したい場合は、以下を実行します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.hsplit(x, (3, 4))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列のスタッキングと分割については[こちら](https://numpy.org/devdocs/user/quickstart.html#quickstart-stacking-arrays)をご覧ください。\n",
    "\n",
    "<span style=\"color: red; \">viewメソッドを使って、元の配列と同じデータを見る新しい配列オブジェクトを作成することができます（浅いコピー）</span>。\n",
    "<span style=\"color: gray; \">[補足]浅いコピーではメモリ上は同一エリアを使います</span>\n",
    "\n",
    "ビューはNumPyの重要な概念です。 NumPyの関数は、インデックスやスライスなどの操作と同様に、可能な限りビューを返します。これは<span style=\"color: red; \">メモリの節約になり、そして高速です（データのコピーを作成する必要がありません）。しかし、注意しなければならないことがあります - <span style=\"color: red; \">ビュー内のデータを変更すると、元の配列も変更されてしまいます</span>。\n",
    "  \n",
    "以下の配列を作成したとしましょう。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "ここで、aをスライスして配列b1を作成し、b1の最初の要素を修正します。これにより、aの対応する要素も変更されます!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "b1 = a[0, :]\n",
    "b1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "b1[0] = 99\n",
    "b1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "<span style=\"color: red; \">copy メソッドを使用すると、配列とそのデータの完全なコピーを作成します (深いコピー)</span>。    \n",
    "  \n",
    "<span style=\"color: gray; \">[補足]深いコピーでは、（浅いコピーはメモリ上は同一であるのにくらべ）メモリ上も別エリアを確保してコピーします（＝別エリア）</span>    \n",
    "  \n",
    "これを配列に使用するには、以下のように実行します。  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "b2 = a.copy()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "コピーやビューについての詳細は[こちら](https://numpy.org/devdocs/user/quickstart.html#quickstart-copies-and-views)をご覧ください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">基本的な配列操作</span>  \n",
    "足し算、引き算、掛け算、割り算などについて説明します。\n",
    "***\n",
    "配列を作成したら、それを使って作業を始めることができます。例えば、\"data\" と \"ones\" という 2 つの配列を作成したとしましょう。  \n",
    "![picture](https://numpy.org/devdocs/_images/np_array_dataones.png)    \n",
    "  \n",
    "プラス記号と一緒に配列を追加することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data = np.array([1, 2])\n",
    "ones = np.ones(2, dtype=int)\n",
    "data + ones"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_indexing.png)  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "もちろん、足し算だけではありません!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data - ones"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data * data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data / data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_sub_mult_divide.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "NumPyの基本的な操作は簡単です。配列の要素の和を求めるには，sum()を使います。これは，1次元配列，2次元配列，高次元の配列で動作します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([1, 2, 3, 4])\n",
    "a.sum()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "<span style=\"color: red; \">2次元配列の行や列を追加するには、軸を指定します</span>。\n",
    "\n",
    "以下の配列から始めると、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "b = np.array([[1, 1], [2, 2]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "以下で行の合計ができます。  \n",
    "<span style=\"color: gray; \">［補足］指定した軸(axis)に沿っていくので、指定された軸の要素が１になるイメージです</span>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "b.sum(axis=0)   #[補足] 行単位なので１行になるように各列の要素を集計   "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "以下で例の合計ができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "b.sum(axis=1)    #[補足] 列単位なので１列になるように各行の要素を集計 "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "基本的な操作の詳細ついては[こちら](https://numpy.org/devdocs/user/quickstart.html#quickstart-basic-operations)をご覧ください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">ブロードキャスティング</span>\n",
    "\n",
    "配列と単一の数値（ベクトルとスカラの間の演算とも呼ばれます）や、2つの異なるサイズの配列の間で演算を行いたい場合があるでしょう。例えば、ある配列(ここでは「data」と呼ぶことにします)にはマイル単位の距離の情報が含まれているかもしれませんが、その情報をキロメートルに変換したいとします。この操作は次のようにして行うことができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data = np.array([1.0, 2.0])\n",
    "data * 1.6"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_multiply_broadcasting.png)  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "NumPyは、乗算はそれぞれのセルで行われる必要を理解しています。この概念はブロードキャストと呼ばれています。<span style=\"color: red; \">ブロードキャスティングは、NumPyが異なる形状の配列に対して演算を実行できるようにするメカニズムです</span>。配列の次元は互換性がなければなりません。例えば、両方の配列の次元が等しい場合や、片方が1の場合などです。 次元に互換性がない場合は、ValueErrorが発生します。  \n",
    "  \n",
    "ブロードキャストについての詳細は[こちら](https://numpy.org/devdocs/user/basics.broadcasting.html#basics-broadcasting)をご覧ください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">より便利な配列操作</span>  \n",
    "  \n",
    "このセクションでは、最大、最小、合計、平均、積、標準偏差などを扱います。\n",
    "***\n",
    "NumPyは集計関数も実行します。min, max, sumに加えて、平均を得るためのmean、要素を掛け合わせた結果を得るためのprod、標準偏差を得るためのstdなどを簡単に実行することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data.max()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data.min()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data.sum()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_aggregation.png)  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "まずは以下の配列、\"a \"から始めましょう。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([[0.45053314, 0.17296777, 0.34376245, 0.5510652],\n",
    "              [0.54627315, 0.05093587, 0.40067661, 0.55645993],\n",
    "              [0.12697628, 0.82485143, 0.26590556, 0.56917101]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "行や列に沿って集計したいというのは非常によくあることです。デフォルトでは、すべてのNumPy集約関数は配列全体の総和を返します。配列の要素の合計または最小値を求めるには、以下のように実行します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a.sum()      #合計"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "あるいは"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a.min()      #最小値"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "集約関数を計算させたい軸を指定できます。例えば、axis=0 を指定することで、各列内の最小値を見つけることができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a.min(axis=0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "上記の4つの値は、配列の列数に対応しています。4列の配列の場合、結果として 4 つの値が得られます。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列のメソッドについての詳細は[こちら](https://numpy.org/devdocs/reference/arrays.ndarray.html#array-ndarray-methods)をご覧ください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">行列の作成</span>\n",
    "Pythonのリストを渡して、NumPy向けの2次元配列（または「行列」）を作ることができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data = np.array([[1, 2], [3, 4]])\n",
    "data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_create_matrix.png)  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "行列を操作する際には、インデックスやスライス操作が便利です。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data[0, 1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data[1:3]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data[0:2, 0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_matrix_indexing.png)  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "ベクトルを集約するのと同じように行列を集約することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data.max()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data.min()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data.sum()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_matrix_aggregation.png)  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "行列内のすべての値を集約することができ、軸パラメータを使用して列または行にまたがって集約することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data.max(axis=0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data.max(axis=1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_matrix_aggregation_row.png)  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "行列を作成したら、同じ大きさの行列が2つあれば、算術演算子を使って足し算や掛け算をすることができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data = np.array([[1, 2], [3, 4]])\n",
    "ones = np.array([[1, 1], [1, 1]])\n",
    "data + ones"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_matrix_arithmetic.png)  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "<span style=\"color: red; \">異なるサイズの行列に対してこれらの算術演算を行うことができますが、1つの行列が1列または1行しかない場合に限ります</span>。この場合、NumPyは<span style=\"color: red; \">ブロードキャスト規則</span>を使って演算を行います。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data = np.array([[1, 2], [3, 4], [5, 6]])\n",
    "ones_row = np.array([[1, 1]])\n",
    "data + ones_row"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_matrix_broadcasting.png)  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "NumPyがN次元配列を表示するとき，最後の軸は最も速く，最初の軸は最も遅くループされることに注意してください。  \n",
    "例えば、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.ones((4, 3, 2))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "NumPyで配列の値を初期化したい場合がよくあります。NumPy には ones() や zeros() のような関数や、乱数を生成する random.Generator クラスがあります。必要なのは、生成してほしい要素数を渡すだけです。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.ones(3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.zeros(3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "rng = np.random.default_rng(0)\n",
    "rng.random(3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_ones_zeros_random.png)  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "また，行列の次元を記述するタプルを与えれば， ones()，zeros()，random() を用いて 2 次元配列を作成することもできます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.ones((3, 2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.zeros((3, 2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "rng.random((3, 2))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_ones_zeros_matrix.png)  \n",
    "\n",
    "0、1、その他の値や初期化されていない値で埋められた配列を作成することについての詳細は、[array creation routines](https://numpy.org/devdocs/reference/routines.array-creation.html#routines-array-creation)参照してください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">乱数の生成</span>\n",
    "\n",
    "<span style=\"color: red; \">乱数生成の使用は、多くの数値計算や機械学習アルゴリズムの構成や評価の重要な部分です。人工ニューラルネットワークで重みをランダムに初期化する場合でも、データをランダムなセットに分割する場合でも、データセットをランダムにシャッフルする場合でも、乱数（実際には再現性のある擬似乱数）を生成できることは不可欠です</span>。\n",
    "\n",
    "Generator.integersを使えば、低位（NumPyに含まれることを忘れないようにしてください）から高位（排他的）までの乱数を生成することができます。endpoint=Trueを設定することで、高位の数値を含むようにすることができます。\n",
    "\n",
    "以下で、0から4までの乱数の2×4配列を生成することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "rng.integers(5, size=(2, 4))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "乱数の生成については[こちら](https://numpy.org/devdocs/reference/random/index.html#numpyrandom)をご覧ください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">ユニークアイテムとカウント数の取得方法</span>  \n",
    "  \n",
    "このセクションでは、np.unique()を扱います。\n",
    "***\n",
    "配列のユニークな要素はnp.uniqueを使えば簡単に見つけることができます。\n",
    "\n",
    "例えば、次のような配列で始まるとします。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([11, 11, 12, 13, 14, 15, 16, 17, 12, 13, 11, 14, 18, 19, 20])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列内の一意な値を表示するには np.unique を使用します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "unique_values = np.unique(a)\n",
    "print(unique_values)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "NumPy配列（配列内のユニークな値の最初のインデックス位置の配列）でユニークな値のインデックスを取得するには、np.unique()に、配列と同様にreturn_index引数を渡すだけです。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "unique_values, indices_list = np.unique(a, return_index=True)\n",
    "print(indices_list)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列と一緒にnp.unique()のreturn_counts引数を渡すことで、NumPy配列内のユニークな値の頻度カウントを取得することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "unique_values, occurrence_count = np.unique(a, return_counts=True)\n",
    "print(occurrence_count)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "これは2次元配列でも動作します! 以下の配列から始めると、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a_2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [1, 2, 3, 4]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "以下で、ユニークな値を見つけることができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "unique_values = np.unique(a_2d)\n",
    "print(unique_values)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "axis 引数が渡されていない場合、2D 配列は平坦化（１次元化）されます。\n",
    "\n",
    "ユニークな行や列を取得したい場合は、必ず axis 引数を渡してください。ユニークな行を取得するには axis=0 を、列を取得するには axis=1 を指定します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "unique_rows = np.unique(a_2d, axis=0)\n",
    "print(unique_rows)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "ユニークな行、インデックスの位置、出現数を取得するには、以下が使えます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "unique_rows, indices, occurrence_count = np.unique(\n",
    "    a_2d, axis=0, return_counts=True, return_index=True)\n",
    "print(unique_rows)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "print(indices)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "print(occurrence_count)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列の中から一意な要素を見つける方法の詳細については、 [unique](https://numpy.org/devdocs/reference/generated/numpy.unique.html#numpy.unique) を参照してください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">行列の転置とリシェイプ</span>\n",
    "このセクションでは， arr.reshape()， arr.transpose()， arr.Tを扱います。\n",
    "***\n",
    "<span style=\"color: red; \">行列を転置する必要があることはよくあることです。NumPy配列には、行列の転置を可能にするTというプロパティがあります</span>。\n",
    "  \n",
    "![picture](https://numpy.org/devdocs/_images/np_transposing_reshaping.png)  \n",
    "  \n",
    "また、行列の次元を切り替える必要があるかもしれません。これは、例えば、データセットとは異なる特定の入力形状を想定したモデルがある場合などに起こります。このような場合に reshape メソッドが役立ちます。単に，行列に必要な新しい次元を渡す必要があるだけです。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data.reshape(2, 3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data.reshape(3, 2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_reshape.png)  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "また、.transpose() を使用して、指定した値に応じて配列の軸を反転させたり変更したりすることもできます。\n",
    "\n",
    "以下の配列で開始した場合、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "arr = np.arange(6).reshape((2, 3))\n",
    "arr"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "arr.transpose() を使用して配列を転置することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "arr.transpose()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "arr.T.を使用することもできます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "arr.T"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列の転置とリシェイプの詳細については、 [transpose](https://numpy.org/devdocs/reference/generated/numpy.transpose.html#numpy.transpose) と [reshape](https://numpy.org/devdocs/reference/generated/numpy.reshape.html#numpy.reshape)を参照してください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">配列を反転させる方法</span>\n",
    "\n",
    "このセクションでは、np.flip()を扱います。\n",
    "***\n",
    "  \n",
    "<span style=\"color: red; \">NumPyのnp.flip()関数では、配列の内容を軸に沿って反転させたり、反転させたりすることができます</span>。np.flip()を使用する際には、反転させたい配列と軸を指定します。軸を指定しなかった場合、NumPyは入力配列のすべての軸に沿って内容を反転します。  \n",
    "  \n",
    "**1次元配列の反転**  \n",
    "  \n",
    "以下のような1次元配列から始めると、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "以下で反転させることができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "reversed_arr = np.flip(arr)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "逆さにした配列を表示したい場合は、以下を実行します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "print('Reversed Array: ', reversed_arr)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "**2次元配列の反転**\n",
    "\n",
    "2次元配列も同じように動作します。\n",
    "\n",
    "以下の配列から始めると、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "arr_2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "以下で、すべての行とすべての列の内容を反転させることができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "reversed_arr = np.flip(arr_2d)\n",
    "print(reversed_arr)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "以下で、行だけを簡単に反転させることができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "reversed_arr_rows = np.flip(arr_2d, axis=0)\n",
    "print(reversed_arr_rows)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "または、以下で列だけを反転させることもできます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "reversed_arr_columns = np.flip(arr_2d, axis=1)\n",
    "print(reversed_arr_columns)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "また、1つの列または行だけの内容を反転させることもできます。例えば、インデックス位置1（2行目）の行の内容を反転させることができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "arr_2d[1] = np.flip(arr_2d[1])\n",
    "print(arr_2d)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "インデックス位置1（2列目）の列を反転させることもできます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "arr_2d[:,1] = np.flip(arr_2d[:,1])\n",
    "print(arr_2d)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列の反転についての詳細は[flip](https://numpy.org/devdocs/reference/generated/numpy.flip.html#numpy.flip)を参照してください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">多次元配列のリシェイプと平坦化</span>  \n",
    "  \n",
    "このセクションでは、.flatten()、ravel()を扱います。\n",
    "***  \n",
    "  \n",
    "<span style=\"color: red; \">配列を平坦化するには、.flatten() と .ravel() の 2 つの一般的な方法があります</span>。この二つの主な違いは、ravel() で作成される新しい配列は実際には親配列への参照 (つまり \"ビュー\" です) であるということです。つまり、新しい配列への変更は親配列にも影響するということです。ravel はコピーを作成しないので、メモリ効率が良いです。\n",
    "\n",
    "以下の配列から始めた場合、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "x = np.array([[1 , 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列を1次元配列に平坦化するには、flattenを使用することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "x.flatten()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "flatten を使用した場合、新しい配列を変更しても親配列は変更されません。  \n",
    "  \n",
    "例えば、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a1 = x.flatten()\n",
    "a1[0] = 99\n",
    "print(x)  # Original array"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "print(a1)  # New array"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "しかし、ravel を使用した場合、新しい配列に加えた変更は親配列に影響を与えます。  \n",
    "  \n",
    "例えば、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a2 = x.ravel()\n",
    "a2[0] = 98\n",
    "print(x)  # Original array"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "print(a2)  # New array"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "flattenについてはの詳細は[ndarray.flatten](https://numpy.org/devdocs/reference/generated/numpy.ndarray.flatten.html#numpy.ndarray.flatten)、ravelの詳細は[ravel](https://numpy.org/devdocs/reference/generated/numpy.ravel.html#numpy.ravel) を参照してください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">詳細を知るためにdocstringにアクセスする方法</span>\n",
    "  \n",
    "このセクションでは、help(), ?, ??について扱います。\n",
    "***\n",
    "  \n",
    "データサイエンスのエコシステムといえば、PythonとNumPyはユーザーのことを考えて構築されています。その最良の例の一つが、組み込みのドキュメントへのアクセスです。すべてのオブジェクトは文字列への参照を含んでおり、これはdocstringとして知られています。ほとんどの場合、このdocstringにはオブジェクトとその使い方の簡単で簡潔な要約が含まれています。Pythonには、この情報にアクセスするのに役立つ help() 関数が組み込まれています。つまり、より多くの情報が必要になったときにはほぼいつでも、 help() を使って必要な情報を素早く見つけることができます。\n",
    "\n",
    "例えば、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "help(max)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "追加情報へのアクセスは非常に便利なので、IPythonでは'?'という文字を使ってこのドキュメントにアクセスし、他の関連情報にもアクセスできるようにしています。\n",
    "IPythonは複数の言語でインタラクティブな計算を行うためのコマンドシェルです。IPythonについての詳しい情報は[こちら](https://ipython.org/)をご覧ください。\n",
    "\n",
    "例えば、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "max?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "この表記法は、オブジェクトメソッドやオブジェクトそのものにも使えます。\n",
    "\n",
    "以下のような配列を作成したとしましょう。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([1, 2, 3, 4, 5, 6])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "すると、多くの有用な情報を得ることができます(最初にa自身の詳細、次にaがインスタンスであるndarrayのdocstringが続きます)。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "これは、関数やその他のオブジェクトを作成した場合にも動作します。ただ、文字列リテラルを使用して関数に docstring を含めることを忘れないでください (\"\" \"\" \"\" またはドキュメントの周りに ''' '' '' を使用してください)。  \n",
    "  \n",
    "例えば、次のような関数を作成したとします。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "def double(a):\n",
    "    '''Return a * 2'''\n",
    "    return a * 2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "この関数に関する情報を得ることができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "double?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "興味のあるオブジェクトのソースコードを読むことで、別のレベルの情報にリーチすることができます。二重のクエスチョンマーク(??)を使うと、ソースコードにアクセスできます。\n",
    "\n",
    "例えば、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "double??"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "知りたいオブジェクトがPython以外の言語でコンパイルされている場合、'??'を使用すると'?'と同じ情報が返されます。これは、例えば組み込みのオブジェクトや型の多くで見られるでしょう。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "len?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "そして、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "len??"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "lenは、Python以外のプログラミング言語でコンパイルされているため、同じ出力を持っています。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">数式を使った作業</span>  \n",
    "  \n",
    "<span style=\"color: red; \">配列上で動作する数式の実装の容易さは、NumPyが科学的なPythonコミュニティでこれほどまでに広く使われている理由の一つです</span>。\n",
    "\n",
    "例えば、これは平均二乗誤差の公式（回帰を扱う教師付き機械学習モデルで使われる中心的な公式）です。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_MSE_formula.png)  \n",
    "  \n",
    "この式の実装は、NumPyではシンプルで簡単です。\n",
    "\n",
    "![picture](https://numpy.org/devdocs/_images/np_MSE_implementation.png)  \n",
    "これが非常にうまく機能するのは、予測値とラベルが1つまたは1000個の値を含むことができるからです。これらは同じサイズである必要があります。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "このように可視化することができます。\n",
    "\n",
    "![picture](https://numpy.org/devdocs/_images/np_mse_viz1.png)  \n",
    "\n",
    "この例では、予測ベクトルとラベルベクトルの両方に3つの値が含まれており、nには3つの値があることを意味します。減算を行った後、ベクトル内の値は2乗されます。NumPyが値を合計し、その結果が予測値の誤差値とモデルの品質のスコアとなります。\n",
    "\n",
    "![picture](https://numpy.org/devdocs/_images/np_MSE_explanation2.png)  \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">NumPyオブジェクトの保存と読み込み方法</span>  \n",
    "  \n",
    "ここでは、np.save、np.savez、np.savetxt、np.load、np.loadtxtを扱います。\n",
    "***\n",
    "  \n",
    "ある時点での、配列をディスクに保存して、コードを再実行することなくロードしたいと思うことがあるでしょう。幸いなことに，NumPyではオブジェクトを保存したりロードしたりする方法がいくつかあります．ndarrayオブジェクトは、通常のテキストファイルを扱うloadtxtとsavetxt関数、NumPyバイナリファイルを扱うloadとsave関数、NumPyファイルを扱うsavez関数を使ってディスクファイルに保存したり、ディスクファイルからロードしたりすることができます（拡張子は.npyです）。  \n",
    "  \n",
    ".npyと.npzファイルは、ファイルが異なるアーキテクチャの別のマシン上にある場合でも、配列を正しく取得できるように、データ、形状、dtype、およびNDアレイを再構築するために必要なその他の情報を格納します。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "1つのndarrayオブジェクトを保存したい場合は、np.saveを使用して.npyファイルとして保存します。複数のndarrayオブジェクトを1つのファイルに保存したい場合は、np.savezを使用して.npzファイルとして保存します。また、複数の配列を1つのファイルに保存するには、savez_compressedを使用して圧縮されたnpz形式で保存することもできます。\n",
    "\n",
    "np.save()を使えば、簡単に保存して読み込んで配列にすることができます。保存したい配列とファイル名を指定するだけです。例えば、このような配列を作成した場合、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([1, 2, 3, 4, 5, 6])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "以下で、これを「filename.npy」として保存することができます。  \n",
    "  \n",
    "<span style=\"color: gray; \">［補足］現在のカレントフォルダに「filename.npy」が作られますので後で削除してください</span>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.save('filename', a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "np.load() を使用して配列を再構築することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "b = np.load('filename.npy')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "配列をチェックしたい場合は、以下を実行します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "print(b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "NumPy配列は，np.savetxtで.csvや.txtファイルのようなプレーンテキストファイルとして保存することができます。  \n",
    "  \n",
    "例えば、以下のような配列を作成した場合、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "csv_arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "以下のように「new_file.csv」という名前の.csvファイルとして簡単に保存することができます。\n",
    "  \n",
    "<span style=\"color: gray; \">［補足］現在のカレントフォルダに「new_file.npy」が作られますので後で削除してください</span>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.savetxt('new_file.csv', csv_arr)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "loadtxt() を使用して、保存したテキストファイルを素早く簡単に読み込むことができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    " np.loadtxt('new_file.csv')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "savetxt()とloadtxt()関数は、ヘッダ、フッタ、デリミタなどの追加のオプションパラメータを受け付けます。テキストファイルは共有しやすくなりますが、.npyや.npzファイルはより小さく、より速く読むことができます。テキストファイルをより高度に扱う必要がある場合（例えば、欠落した値を含む行を扱う必要がある場合など）、genfromtxt関数を使用することになります。\n",
    "\n",
    "savetxtを使用すると、ヘッダ、フッタ、コメントなどを指定することができます。\n",
    "\n",
    "入力および出力ルーチンの詳細については、[こちら](https://numpy.org/devdocs/reference/routines.io.html#routines-io)を参照してください。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">CSVのインポートとエクスポート</span>  \n",
    "  \n",
    "既存の情報を含んだCSVで読み込むのが簡単です。一番簡単で良いのは[Pandas](https://pandas.pydata.org/)を使うことです。\n",
    "  \n",
    "<span style=\"color: gray; \">［補足］以降のコマンドを実行するためにカレントフォルダに「music.csv」を作成します。</span>\n",
    "<span style=\"color: gray; \">データは下記です</span>  \n",
    "  \n",
    "Artist,Genru,Listener,Plays  \n",
    "Billie Holiday,Jazz,1300000,27000000  \n",
    "Jimmie Hendrix,Rock,2700000,70000000  \n",
    "Miles Davis,Jazz,150000,48000000  \n",
    "SIA,Pops,2000000,74000000  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "# テストファイルを作成します\n",
    "with open('music.csv', 'w') as f:\n",
    "    f.write(\"Artist,Genru,Listener,Plays\\n\")\n",
    "    f.write(\"Billie Holiday,Jazz,1300000,27000000\\n\")\n",
    "    f.write(\"Jimmie Hendrix,Rock,2700000,70000000\\n\")\n",
    "    f.write(\"Miles Davis,Jazz,150000,48000000\\n\")\n",
    "    f.write(\"SIA,Pops,2000000,74000000\\n\")\n",
    "    f.close"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "# If all of your columns are the same type:\n",
    "x = pd.read_csv('music.csv', header=0).values\n",
    "print(x)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "# You can also simply select the columns you need:\n",
    "x = pd.read_csv('music.csv', usecols=['Artist', 'Plays']).values\n",
    "print(x)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_pandas.png)  \n",
    "\n",
    "配列のエクスポートもPandasを使えば簡単です。NumPyに慣れていない方は、配列の値からPandasのデータフレームを作成して、PandasでCSVファイルに書き出してみるのもいいかもしれません。\n",
    "\n",
    "以下の配列 \"a \"を作成した場合、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([[-2.58289208,  0.43014843, -1.24082018, 1.59572603],\n",
    "              [ 0.99027828, 1.17150989,  0.94125714, -0.14692469],\n",
    "              [ 0.76989341,  0.81299683, -0.95068423, 0.11769564],\n",
    "              [ 0.20484034,  0.34784527,  1.96979195, 0.51992837]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "Pandsのデータフレームを作成することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "df = pd.DataFrame(a)\n",
    "print(df)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "以下で、簡単にデータフレームを保存することができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "df.to_csv('pd.csv')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "そして、以下でCSVを読み込み、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "data = pd.read_csv('pd.csv')\n",
    "data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "![picture](https://numpy.org/devdocs/_images/np_readcsv.png)  \n",
    "NumPyのsavetxtメソッドを使って配列を保存することもできます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "np.savetxt('np.csv', a, fmt='%.2f', delimiter=',', header='1,  2,  3,  4')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "コマンドラインを使っている場合は、次のようなコマンドでいつでも保存したCSVを読み込むことができます。  \n",
    "<span style=\"color: gray; \">［補足］本学習環境(DeepAelurus）でcatコマンドの代わりにWindowsのtypeコマンドで確認します</span>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "# cat np.csv   オリジナルコード\n",
    "!type np.csv"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "または、テキストエディタでいつでも開くことができます!\n",
    "\n",
    "Pandasについて詳しく知りたい方は、[Pandasの公式ドキュメント](https://pandas.pydata.org/index.html)をご覧ください。[Pandasの公式インストール情報](https://pandas.pydata.org/pandas-docs/stable/getting_started/install.html)でPandasのインストール方法をご紹介します。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "# <span style=\"color: blue; \">Matplotlibによる配列のプロット</span>\n",
    "値のプロットを作成する必要がある場合，Matplotlibを使用すると非常に簡単です．\n",
    "  \n",
    "例えば、以下のような配列があれば、"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "a = np.array([2, 1, 5, 7, 4, 6, 8, 14, 10, 9, 18, 20, 22])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "すでにMatplotlibがインストールされている場合は、それを使ってインポートすることができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# If you're using Jupyter Notebook, you may also want to run the following\n",
    "# line of code to display your code in the notebook:\n",
    "\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "値をプロットするために必要なのは、実行することだけです。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "plt.plot(a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "コマンドラインから実行している場合は、以下の操作が必要になります。  \n",
    "&nbsp;>>>plt.show()  \n",
    "<span style=\"color: gray; \">［補足］本学習環境では不要です。</span>\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "例えば、1次元配列をこのようにプロットすることができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "x = np.linspace(0, 5, 20)\n",
    "y = np.linspace(0, 10, 20)\n",
    "plt.plot(x, y, 'purple') # line\n",
    "plt.plot(x, y, 'o')      # dots"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "Matplotlibを使用すると、膨大な数の可視化オプションにアクセスすることができます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "deletable": false,
    "editable": false
   },
   "outputs": [],
   "source": [
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "fig = plt.figure()\n",
    "ax = Axes3D(fig)\n",
    "X = np.arange(-5, 5, 0.15)\n",
    "Y = np.arange(-5, 5, 0.15)\n",
    "X, Y = np.meshgrid(X, Y)\n",
    "R = np.sqrt(X**2 + Y**2)\n",
    "Z = np.sin(R)\n",
    "\n",
    "ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap='viridis')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "Matplotlibとそれができることについての詳細を読むには、[公式ドキュメント](https://matplotlib.org/)を見てください。Matplotlibのインストール方法については、[公式のインストールセクション](https://matplotlib.org/users/installing.html)を参照してください。\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "run_control": {
     "frozen": true
    }
   },
   "source": [
    "Image credits: Jay Alammar http://jalammar.github.io/"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.8"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": true
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
